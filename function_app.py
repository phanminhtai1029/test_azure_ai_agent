import azure.functions as func
import logging
import json
import os
from datetime import datetime
from typing import Optional, Dict, Any

# Import libraries
from google import genai
from supabase import create_client, Client
from pymongo import MongoClient
import requests

# Initialize FunctionApp
app = func.FunctionApp()

# ==================== CONFIGURATION ====================

# Environment variables
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
MONGODB_CONNECTION_STRING = os.environ.get("MONGODB_CONNECTION_STRING")
SUPABASE_URL = os.environ.get("SUPABASE_URL")
SUPABASE_KEY = os.environ.get("SUPABASE_KEY")

# Initialize clients
gemini_client = genai.Client(api_key=GEMINI_API_KEY)
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)
mongo_client = MongoClient(MONGODB_CONNECTION_STRING)
db = mongo_client.agent_db

# ==================== HELPER FUNCTIONS ====================

def send_telegram_message(text: str, chat_id: str = None) -> bool:
    """G·ª≠i tin nh·∫Øn v·ªÅ Telegram"""
    try:
        target_chat_id = chat_id or TELEGRAM_CHAT_ID
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            "chat_id": target_chat_id,
            "text": text,
            "parse_mode": "Markdown"
        }
        response = requests.post(url, json=payload)
        return response.status_code == 200
    except Exception as e:
        logging.error(f"Error sending Telegram message: {e}")
        return False

def create_embedding(text: str) -> Optional[list]:
    """T·∫°o embedding b·∫±ng Gemini"""
    try:
        response = gemini_client.models.embed_content(
            model="models/text-embedding-004",
            contents=text
        )
        if hasattr(response, 'embeddings') and response.embeddings:
            embedding = response.embeddings[0]
            if hasattr(embedding, 'values'):
                return embedding.values
            else:
                return list(embedding)
        elif hasattr(response, 'embedding'):
            if hasattr(response.embedding, 'values'):
                return response.embedding.values
            else:
                return list(response.embedding)
        return None
    except Exception as e:
        logging.error(f"Error creating embedding: {e}")
        return None

def search_rag_documents(query: str, threshold: float = 0.5, count: int = 3) -> list:
    """T√¨m ki·∫øm t√†i li·ªáu t∆∞∆°ng t·ª± trong Supabase RAG"""
    try:
        query_embedding = create_embedding(query)
        if not query_embedding:
            return []
        
        result = supabase.rpc(
            "match_documents",
            {
                "query_embedding": query_embedding,
                "match_threshold": threshold,
                "match_count": count
            }
        ).execute()
        
        return result.data if result.data else []
    except Exception as e:
        logging.error(f"Error searching RAG: {e}")
        return []

def generate_ai_response(user_message: str, context: str = "") -> str:
    """T·∫°o ph·∫£n h·ªìi b·∫±ng Gemini AI"""
    try:
        prompt = f"""B·∫°n l√† AI Planning Assistant - tr·ª£ l√Ω l·∫≠p k·∫ø ho·∫°ch th√¥ng minh.

Nhi·ªám v·ª•: Gi√∫p ng∆∞·ªùi d√πng v·ªõi m·ª•c ti√™u v√† k·∫ø ho·∫°ch c·ªßa h·ªç.

Ng·ªØ c·∫£nh t·ª´ t√†i li·ªáu ƒë√£ l∆∞u:
{context}

Tin nh·∫Øn ng∆∞·ªùi d√πng: {user_message}

H√£y tr·∫£ l·ªùi ng·∫Øn g·ªçn, h·ªØu √≠ch b·∫±ng ti·∫øng Vi·ªát. N·∫øu ng∆∞·ªùi d√πng ƒë∆∞a ra m·ª•c ti√™u, h√£y:
1. X√°c nh·∫≠n m·ª•c ti√™u
2. ƒê·ªÅ xu·∫•t c√°c b∆∞·ªõc th·ª±c hi·ªán
3. Khuy·∫øn kh√≠ch h·ªç"""

        response = gemini_client.models.generate_content(
            model="gemini-2.0-flash-exp",
            contents=prompt
        )
        return response.text
    except Exception as e:
        logging.error(f"Error generating AI response: {e}")
        return "Xin l·ªói, t√¥i ƒëang g·∫∑p s·ª± c·ªë k·ªπ thu·∫≠t. Vui l√≤ng th·ª≠ l·∫°i sau."

def save_user_message(chat_id: str, message: str):
    """L∆∞u tin nh·∫Øn ng∆∞·ªùi d√πng v√†o MongoDB"""
    try:
        db.user_messages.insert_one({
            "chat_id": chat_id,
            "message": message,
            "timestamp": datetime.utcnow()
        })
        logging.info(f"Saved message from {chat_id}")
    except Exception as e:
        logging.error(f"Error saving message: {e}")

# ==================== FUNCTION 1: TELEGRAM WEBHOOK ====================

@app.route(route="telegram", auth_level=func.AuthLevel.ANONYMOUS, methods=["POST"])
def TelegramWebhook(req: func.HttpRequest) -> func.HttpResponse:
    """
    Function x·ª≠ l√Ω webhook t·ª´ Telegram
    URL: /api/telegram
    Method: POST
    """
    logging.info('ü§ñ Telegram webhook triggered')

    try:
        # Parse request body
        req_body = req.get_json()
        logging.info(f"Received: {json.dumps(req_body, ensure_ascii=False)}")

        # Ki·ªÉm tra c√≥ message kh√¥ng
        if 'message' not in req_body:
            logging.info("No message in webhook")
            return func.HttpResponse("OK", status_code=200)

        message = req_body['message']
        chat_id = str(message.get('chat', {}).get('id', ''))
        text = message.get('text', '')
        
        if not text:
            logging.info("No text in message")
            return func.HttpResponse("OK", status_code=200)

        logging.info(f"üì© Chat ID: {chat_id}, Message: {text}")

        # L∆∞u tin nh·∫Øn v√†o MongoDB
        save_user_message(chat_id, text)

        # X·ª≠ l√Ω commands
        if text.startswith('/'):
            if text == '/start':
                response_text = """üëã *Xin ch√†o! T√¥i l√† AI Planning Assistant!*

T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
‚úÖ T·∫°o k·∫ø ho·∫°ch tu·∫ßn t·ª± ƒë·ªông
‚úÖ Nh·∫Øc nh·ªü c√°c m·ª•c ti√™u h√†ng ng√†y
‚úÖ T√¨m ki·∫øm t√†i li·ªáu v√† ghi ch√∫
‚úÖ Theo d√µi ti·∫øn ƒë·ªô c√¥ng vi·ªác

*C√°ch s·ª≠ d·ª•ng:*
G·ª≠i m·ª•c ti√™u c·ªßa b·∫°n cho t√¥i, v√≠ d·ª•:
"T√¥i mu·ªën h·ªçc Python trong 2 tu·∫ßn"

Ho·∫∑c d√πng c√°c l·ªánh:
/help - Xem h∆∞·ªõng d·∫´n chi ti·∫øt
/plan - Xem k·∫ø ho·∫°ch hi·ªán t·∫°i"""
                
            elif text == '/help':
                response_text = """üìñ *H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng*

*1Ô∏è‚É£ T·∫°o K·∫ø Ho·∫°ch:*
G·ª≠i m·ª•c ti√™u c·ªßa b·∫°n, v√≠ d·ª•:
- "T√¥i mu·ªën h·ªçc Python trong 2 tu·∫ßn"
- "Gi√∫p t√¥i t·∫≠p th·ªÉ d·ª•c ƒë·ªÅu ƒë·∫∑n"

*2Ô∏è‚É£ T√¨m Ki·∫øm T√†i Li·ªáu:*
H·ªèi v·ªÅ b·∫•t k·ª≥ ch·ªß ƒë·ªÅ n√†o, t√¥i s·∫Ω t√¨m trong t√†i li·ªáu ƒë√£ l∆∞u.

*3Ô∏è‚É£ Xem K·∫ø Ho·∫°ch:*
G√µ /plan ƒë·ªÉ xem k·∫ø ho·∫°ch hi·ªán t·∫°i

*4Ô∏è‚É£ T·ª± ƒê·ªông H√≥a:*
- K·∫ø ho·∫°ch tu·∫ßn m·ªõi: Ch·ªß nh·∫≠t 9h s√°ng
- Nh·∫Øc nh·ªü h√†ng ng√†y: 4 l·∫ßn (6h, 12h, 18h, 21h)
- Databases ƒë∆∞·ª£c l√†m m·ªõi t·ª± ƒë·ªông

H√£y b·∫Øt ƒë·∫ßu b·∫±ng c√°ch g·ª≠i m·ª•c ti√™u c·ªßa b·∫°n! üöÄ"""
                
            elif text == '/plan':
                # L·∫•y k·∫ø ho·∫°ch t·ª´ MongoDB
                try:
                    plans = list(db.approved_plans.find(
                        {"chat_id": chat_id}
                    ).sort("created_at", -1).limit(5))
                    
                    if plans:
                        response_text = "üìã *K·∫ø Ho·∫°ch C·ªßa B·∫°n:*\n\n"
                        for i, plan in enumerate(plans, 1):
                            goal = plan.get('goal', 'N/A')
                            status = plan.get('status', 'pending')
                            created = plan.get('created_at', datetime.utcnow())
                            
                            # Format date
                            if isinstance(created, datetime):
                                date_str = created.strftime('%d/%m/%Y')
                            else:
                                date_str = 'N/A'
                            
                            status_emoji = "‚úÖ" if status == "completed" else "üîÑ"
                            response_text += f"{status_emoji} *{i}. {goal}*\n"
                            response_text += f"   üìÖ {date_str} | Status: {status}\n\n"
                    else:
                        response_text = """üìã *B·∫°n ch∆∞a c√≥ k·∫ø ho·∫°ch n√†o*

H√£y g·ª≠i m·ª•c ti√™u c·ªßa b·∫°n ƒë·ªÉ t√¥i t·∫°o k·∫ø ho·∫°ch!

V√≠ d·ª•:
- "T√¥i mu·ªën h·ªçc l·∫≠p tr√¨nh"
- "Gi√∫p t√¥i gi·∫£m c√¢n trong 1 th√°ng"
- "L√†m sao ƒë·ªÉ c·∫£i thi·ªán ti·∫øng Anh?\""""
                        
                except Exception as e:
                    logging.error(f"Error fetching plans: {e}")
                    response_text = "Xin l·ªói, c√≥ l·ªói khi l·∫•y k·∫ø ho·∫°ch. Vui l√≤ng th·ª≠ l·∫°i."
                    
            else:
                response_text = """‚ùì *L·ªánh kh√¥ng h·ª£p l·ªá*

C√°c l·ªánh c√≥ s·∫µn:
/start - B·∫Øt ƒë·∫ßu
/help - H∆∞·ªõng d·∫´n
/plan - Xem k·∫ø ho·∫°ch

Ho·∫∑c g·ª≠i tin nh·∫Øn b√¨nh th∆∞·ªùng ƒë·ªÉ chat v·ªõi t√¥i!"""
        
        else:
            # Tin nh·∫Øn th∆∞·ªùng - T√¨m ki·∫øm RAG v√† t·∫°o ph·∫£n h·ªìi
            logging.info("Processing regular message with RAG")
            
            # T√¨m ki·∫øm t√†i li·ªáu li√™n quan
            rag_results = search_rag_documents(text, threshold=0.3, count=2)
            
            context = ""
            if rag_results:
                logging.info(f"Found {len(rag_results)} RAG results")
                context = "\n\n".join([
                    f"- {doc['content']}" for doc in rag_results
                ])
            else:
                logging.info("No RAG results found")
            
            # T·∫°o ph·∫£n h·ªìi AI
            response_text = generate_ai_response(text, context)

        # G·ª≠i ph·∫£n h·ªìi v·ªÅ Telegram
        success = send_telegram_message(response_text, chat_id)
        
        if success:
            logging.info(f"‚úÖ Response sent successfully to {chat_id}")
        else:
            logging.error(f"‚ùå Failed to send response to {chat_id}")

        return func.HttpResponse("OK", status_code=200)

    except Exception as e:
        logging.error(f"‚ùå Error in TelegramWebhook: {e}", exc_info=True)
        
        # C·ªë g·∫Øng g·ª≠i error message v·ªÅ Telegram
        try:
            if 'chat_id' in locals():
                send_telegram_message(
                    "Xin l·ªói, c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.",
                    chat_id
                )
        except:
            pass
        
        return func.HttpResponse(
            json.dumps({"error": str(e)}),
            status_code=200  # Tr·∫£ 200 ƒë·ªÉ Telegram kh√¥ng retry
        )

# ==================== FUNCTION 2: WEEKLY PLANNER ====================

@app.timer_trigger(schedule="0 0 9 * * 0", arg_name="myTimer", run_on_startup=False)
def WeeklyPlanner(myTimer: func.TimerRequest) -> None:
    """
    T·∫°o k·∫ø ho·∫°ch tu·∫ßn m·ªõi m·ªói Ch·ªß nh·∫≠t 9h s√°ng
    Schedule: 0 0 9 * * 0 (Cron format: gi√¢y ph√∫t gi·ªù ng√†y th√°ng th·ª©)
    Th·ª© 0 = Ch·ªß nh·∫≠t
    """
    logging.info('üìÖ WeeklyPlanner triggered')
    
    try:
        # L·∫•y user profile t·ª´ MongoDB
        users = list(db.user_profile.find({}))
        
        if not users:
            logging.warning("No users found in user_profile")
            return
        
        for user in users:
            chat_id = user.get('chat_id')
            if not chat_id or chat_id == 'temp':
                continue
            
            logging.info(f"Creating weekly plan for user: {chat_id}")
            
            # L·∫•y pending plans c·ªßa user
            pending_plans = list(db.pending_plans.find(
                {"chat_id": chat_id, "status": "pending"}
            ).limit(5))
            
            if not pending_plans:
                # G·ª≠i reminder ƒë·ªÉ t·∫°o k·∫ø ho·∫°ch
                message = """üìÖ *K·∫ø Ho·∫°ch Tu·∫ßn M·ªõi*

Ch√†o bu·ªïi s√°ng Ch·ªß nh·∫≠t! üåÖ

B·∫°n ch∆∞a c√≥ k·∫ø ho·∫°ch n√†o cho tu·∫ßn n√†y. H√£y g·ª≠i m·ª•c ti√™u c·ªßa b·∫°n ƒë·ªÉ t√¥i gi√∫p t·∫°o k·∫ø ho·∫°ch nh√©!

V√≠ d·ª•:
- "T√¥i mu·ªën h·ªçc Python c∆° b·∫£n"
- "Gi√∫p t√¥i t·∫≠p th·ªÉ d·ª•c ƒë·ªÅu ƒë·∫∑n"
- "C·∫£i thi·ªán k·ªπ nƒÉng giao ti·∫øp"

H√£y b·∫Øt ƒë·∫ßu tu·∫ßn m·ªõi v·ªõi m·ª•c ti√™u r√µ r√†ng! üí™"""
                
                send_telegram_message(message, chat_id)
                continue
            
            # T·∫°o t·ªïng h·ª£p k·∫ø ho·∫°ch
            plan_summary = "üìã *K·∫ø Ho·∫°ch Tu·∫ßn N√†y:*\n\n"
            
            for i, plan in enumerate(pending_plans, 1):
                goal = plan.get('goal', 'N/A')
                plan_summary += f"{i}. {goal}\n"
            
            plan_summary += "\nüí° *G·ª£i √Ω:*\n"
            plan_summary += "‚Ä¢ Chia nh·ªè m·ª•c ti√™u th√†nh c√°c b∆∞·ªõc nh·ªè\n"
            plan_summary += "‚Ä¢ L√†m vi·ªác ƒë·ªÅu ƒë·∫∑n m·ªói ng√†y\n"
            plan_summary += "‚Ä¢ Theo d√µi ti·∫øn ƒë·ªô v√† ƒëi·ªÅu ch·ªânh k·ªãp th·ªùi\n\n"
            plan_summary += "Ch√∫c b·∫°n m·ªôt tu·∫ßn th√†nh c√¥ng! üöÄ"
            
            send_telegram_message(plan_summary, chat_id)
            logging.info(f"‚úÖ Weekly plan sent to {chat_id}")
        
        logging.info(f"‚úÖ WeeklyPlanner completed for {len(users)} users")
        
    except Exception as e:
        logging.error(f"‚ùå Error in WeeklyPlanner: {e}", exc_info=True)


# ==================== FUNCTION 3: DAILY REMINDER ====================

@app.timer_trigger(schedule="0 0 6,12,18,21 * * *", arg_name="myTimer", run_on_startup=False)
def DailyReminder(myTimer: func.TimerRequest) -> None:
    """
    G·ª≠i nh·∫Øc nh·ªü h√†ng ng√†y 4 l·∫ßn/ng√†y
    Schedule: 0 0 6,12,18,21 * * * 
    - 6h s√°ng, 12h tr∆∞a, 18h chi·ªÅu, 21h t·ªëi
    """
    logging.info('‚è∞ DailyReminder triggered')
    
    try:
        current_hour = datetime.utcnow().hour + 7  # UTC+7 for Vietnam
        if current_hour >= 24:
            current_hour -= 24
        
        logging.info(f"Current hour (Vietnam): {current_hour}")
        
        # L·∫•y users t·ª´ MongoDB
        users = list(db.user_profile.find({}))
        
        if not users:
            logging.warning("No users found in user_profile")
            return
        
        for user in users:
            chat_id = user.get('chat_id')
            if not chat_id or chat_id == 'temp':
                continue
            
            # Check xem c√≥ reminder_times kh√¥ng
            reminder_times = user.get('reminder_times', ['06:00', '12:00', '18:00', '21:00'])
            
            # Ki·ªÉm tra xem gi·ªù hi·ªán t·∫°i c√≥ trong reminder_times kh√¥ng
            current_time = f"{current_hour:02d}:00"
            if current_time not in reminder_times:
                continue
            
            logging.info(f"Sending reminder to user: {chat_id} at {current_time}")
            
            # L·∫•y approved plans c·ªßa user
            plans = list(db.approved_plans.find(
                {"chat_id": chat_id, "status": {"$ne": "completed"}}
            ).limit(3))
            
            if not plans:
                # Kh√¥ng c√≥ k·∫ø ho·∫°ch, g·ª≠i reminder t·∫°o k·∫ø ho·∫°ch
                if current_hour == 6:  # Ch·ªâ g·ª≠i v√†o bu·ªïi s√°ng
                    message = """‚òÄÔ∏è *Ch√†o Bu·ªïi S√°ng!*

B·∫°n ch∆∞a c√≥ k·∫ø ho·∫°ch n√†o. H√£y b·∫Øt ƒë·∫ßu ng√†y m·ªõi b·∫±ng c√°ch ƒë·∫∑t m·ª•c ti√™u cho m√¨nh nh√©!

G·ª≠i m·ª•c ti√™u c·ªßa b·∫°n ƒë·ªÉ t√¥i gi√∫p t·∫°o k·∫ø ho·∫°ch. üí™"""
                    send_telegram_message(message, chat_id)
            else:
                # C√≥ k·∫ø ho·∫°ch, g·ª≠i reminder
                time_messages = {
                    6: "‚òÄÔ∏è *Ch√†o Bu·ªïi S√°ng!*",
                    12: "üå§Ô∏è *Ngh·ªâ Tr∆∞a R·ªìi!*",
                    18: "üåÜ *Bu·ªïi Chi·ªÅu Vui V·∫ª!*",
                    21: "üåô *Bu·ªïi T·ªëi An L√†nh!*"
                }
                
                greeting = time_messages.get(current_hour, "‚è∞ *Nh·∫Øc Nh·ªü*")
                
                message = f"{greeting}\n\nüìã *K·∫ø Ho·∫°ch H√¥m Nay:*\n\n"
                
                for i, plan in enumerate(plans, 1):
                    goal = plan.get('goal', 'N/A')
                    message += f"{i}. {goal}\n"
                
                message += "\nüí™ H√£y ti·∫øp t·ª•c c·ªë g·∫Øng nh√©!"
                
                send_telegram_message(message, chat_id)
                logging.info(f"‚úÖ Reminder sent to {chat_id}")
        
        logging.info(f"‚úÖ DailyReminder completed for {len(users)} users")
        
    except Exception as e:
        logging.error(f"‚ùå Error in DailyReminder: {e}", exc_info=True)


# ==================== FUNCTION 4: KEEP ALIVE ====================

@app.timer_trigger(schedule="0 0 0 */5 * *", arg_name="myTimer", run_on_startup=False)
def KeepAlive(myTimer: func.TimerRequest) -> None:
    """
    Ping databases m·ªói 5 ng√†y ƒë·ªÉ tr√°nh sleep
    Schedule: 0 0 0 */5 * * (M·ªói 5 ng√†y l√∫c 00:00)
    """
    logging.info('üîÑ KeepAlive triggered')
    
    try:
        # Ping MongoDB
        mongo_result = db.command('ping')
        logging.info(f"‚úÖ MongoDB ping: {mongo_result}")
        
        # Ping Supabase b·∫±ng c√°ch query documents table
        supabase_result = supabase.table('documents').select('id').limit(1).execute()
        logging.info(f"‚úÖ Supabase ping: {len(supabase_result.data) if supabase_result.data else 0} records")
        
        # Test Gemini API
        test_response = gemini_client.models.generate_content(
            model="gemini-2.0-flash-exp",
            contents="Say 'OK' in one word"
        )
        logging.info(f"‚úÖ Gemini ping: {test_response.text[:20]}")
        
        # G·ª≠i th√¥ng b√°o v·ªÅ Telegram
        message = """üîÑ *H·ªá Th·ªëng ƒêang Ho·∫°t ƒê·ªông*

‚úÖ MongoDB: Connected
‚úÖ Supabase: Connected
‚úÖ Gemini API: Active

T·∫•t c·∫£ d·ªãch v·ª• ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng! üíö"""
        
        send_telegram_message(message)
        
        logging.info("‚úÖ KeepAlive completed successfully")
        
    except Exception as e:
        logging.error(f"‚ùå Error in KeepAlive: {e}", exc_info=True)
        
        # G·ª≠i error alert
        try:
            error_message = f"""‚ö†Ô∏è *KeepAlive Error*

C√≥ l·ªói x·∫£y ra khi ping databases:
{str(e)[:200]}

Vui l√≤ng ki·ªÉm tra h·ªá th·ªëng!"""
            send_telegram_message(error_message)
        except:
            pass